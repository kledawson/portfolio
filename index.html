<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Colony Portfolio - Data Rover</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 
      *** FIX: Add Import Map ***
      This tells the browser how to resolve "bare" module specifiers 
      like 'three' or 'three/examples/jsm/...'
    -->
    <script type="importmap">
    {
      "imports": {
        "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js",
        "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
      }
    }
    </script>

    <style>
        /* Ensure the body and canvas cover the full viewport */
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #0A192F; /* Deep space background */
        }
        canvas {
            display: block;
        }
        /* Style for the main container to overlay the 3D scene */
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allows clicks to pass through to the canvas unless on a UI element */
        }
        /* Ensure UI elements can be interacted with */
        #nav a, #hero-content button, #info-box {
            pointer-events: auto;
            transition: all 0.3s ease;
        }
        /* Custom scrollbar for better aesthetics, though not needed yet due to overflow:hidden */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #0A192F;
        }
        ::-webkit-scrollbar-thumb {
            background: #4B5563;
            border-radius: 4px;
        }
    </style>
</head>
<body>

    <!-- Three.js Canvas Container --><div id="three-container" class="fixed inset-0 z-0"></div>

    <!-- UI Overlay (Tailwind CSS) --><div id="ui-overlay" class="text-gray-100">
        <!-- Navigation Bar --><header class="p-6 flex justify-between items-center">
            <h1 class="text-3xl font-extrabold tracking-tight pointer-events-auto">
                <span class="text-sky-400">DAWSON.</span>LE
            </h1>
            <nav id="nav" class="flex space-x-6 pointer-events-auto">
                <a href="#" class="text-lg hover:text-sky-400 p-2 rounded-lg bg-gray-900/50 backdrop-blur-sm">Mission Log</a>
                <a href="https://github.com/your-username" target="_blank" class="text-lg hover:text-sky-400 p-2 rounded-lg bg-gray-900/50 backdrop-blur-sm">GitHub Base</a>
            </nav>
        </header>

        <!-- Dynamic Project Info Box (appears on hover) --><div id="info-box" class="fixed bottom-8 left-1/2 -translate-x-1/2 p-4 rounded-xl shadow-2xl bg-gray-900/80 backdrop-blur-md opacity-0 transition-opacity duration-300 pointer-events-none border border-sky-500/50">
            <h3 id="info-title" class="text-xl font-bold text-sky-400"></h3>
            <p id="info-description" class="text-sm text-gray-300"></p>
            <a id="info-link" href="#" target="_blank" class="text-sky-300 hover:text-sky-500 text-sm mt-2 block invisible">View Mission ></a>
        </div>

        <!-- Instructions for the user --><div id="instructions" class="fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-gray-900/80 backdrop-blur-md text-white p-6 rounded-lg shadow-2xl border border-sky-500/50 z-50 text-center pointer-events-auto">
            <p class="text-lg font-semibold mb-2">Welcome, Explorer!</p>
            <p class="text-md mb-2">Use **WASD** to move and **A/D** to turn the Rover.</p>
            <p class="text-md mb-4">Use **Q** to glide up and **E** to glide down.</p>
            <p class="text-md mb-4">Use your mouse/finger to orbit the camera.</p>
            <button id="start-exploration" class="bg-sky-600 hover:bg-sky-500 text-white font-bold py-2 px-6 rounded-lg transform hover:scale-105 transition duration-300">
                Start Exploration
            </button>
        </div>
    </div>

    <script type="module">
        // *** FIX 1: Use bare module specifiers (defined in import map) ***
        import * as THREE from 'three';
        import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

        // Three.js setup variables
        let scene, camera, renderer, controls;
        let container;
        let raycaster;
        
        // Declare THREE-dependent objects
        let pointer = null; 
        let clock = null; 
        let roverForce = null; 
        let roverVelocity = null;
        
        let projects = [];
        let intersectedObject = null;
        let projectMaterial, roverMaterial, groundMaterial;

        // --- Rover Physics Variables ---
        const keyStates = {};
        
        let roverMass = 5.0;            
        const thrustMagnitude = 20.0;   
        const roverFriction = 0.75;     
        const airFriction = 0.99;       
        const lunarGravity = 0.5;
        const rotationSpeedFactor = 0.3; 
        const brakingSpeed = 0.3; 

        // Angular Constants (for smooth rotation)
        let roverAngularVelocity = 0; 
        const roverAngularAcceleration = 3.0; 
        const roverAngularDamping = 0.5; 

        // Derived Braking constants 
        const turnLinearBrakingFactor = 0.6; 
        const generalLinearBrakingFactor = 0.1; 

        const groundCollisionY = 0.0; 

        let rover;

        // *** FIX 2: Declare DOM element variables here (as null) ***
        let infoBox = null;
        let infoTitle = null;
        let infoDescription = null;
        let infoLink = null;
        let instructionsOverlay = null;
        let startExplorationBtn = null;


        // --- Initialization ---
        function init() {
            container = document.getElementById('three-container');

            // *** FIX 3: Initialize ALL external objects (THREE and DOM) INSIDE init() ***
            clock = new THREE.Clock(); 
            pointer = new THREE.Vector2(); 
            roverForce = new THREE.Vector3(); 
            roverVelocity = new THREE.Vector3();
            
            // Initialize DOM elements
            infoBox = document.getElementById('info-box');
            infoTitle = document.getElementById('info-title');
            infoDescription = document.getElementById('info-description');
            infoLink = document.getElementById('info-link');
            instructionsOverlay = document.getElementById('instructions');
            startExplorationBtn = document.getElementById('start-exploration');

            
            // 1. Scene & Background (Starry Sky)
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0A192F); 

            // Let's create a simple starfield for the background
            const starGeometry = new THREE.BufferGeometry();
            const starMaterial = new THREE.PointsMaterial({
                color: 0xcccccc,
                size: 0.1,
                transparent: true,
                opacity: 0.7
            });
            const starVertices = [];
            for (let i = 0; i < 10000; i++) {
                const x = THREE.MathUtils.randFloatSpread(200);
                const y = THREE.MathUtils.randFloatSpread(200);
                const z = THREE.MathUtils.randFloatSpread(200);
                starVertices.push(x, y, z);
            }
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);


            // 2. Camera
            camera = new THREE.PerspectiveCamera(
                45, 
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            camera.position.set(5, 7, 5);

            // 3. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true; 
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            container.appendChild(renderer.domElement);

            // 4. Materials (defined once for consistency)
            projectMaterial = new THREE.MeshStandardMaterial({
                color: 0x0EA5E9, 
                metalness: 0.7,
                roughness: 0.3,
                emissive: 0x0EA5E9,
                emissiveIntensity: 0.1,
                flatShading: true
            });
            roverMaterial = new THREE.MeshStandardMaterial({
                color: 0xFBBD23, 
                metalness: 0.8,
                roughness: 0.2,
                flatShading: true
            });
            groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x374151, 
                metalness: 0.4,
                roughness: 0.8,
                flatShading: true
            });

            // 5. World Objects
            createWorld();

            // 6. Lighting
            createLights();

            // 7. Raycaster for picking objects
            raycaster = new THREE.Raycaster();

            // 8. Controls (OrbitControls, now targeting the Rover)
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; 
            controls.dampingFactor = 0.05;
            controls.minDistance = 5;
            controls.maxDistance = 30;
            controls.target.copy(rover.position); 
            controls.maxPolarAngle = Math.PI / 2 - 0.1; 

            // Event Listeners (Listeners are attached inside init() now)
            onWindowResize();
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('pointermove', onPointerMove);
            document.addEventListener('keydown', onKeyDown, false); 
            document.addEventListener('keyup', onKeyUp, false); 
            
            // Hide instructions when "Start Exploration" is clicked
            // This will now work because startExplorationBtn is guaranteed to be found
            startExplorationBtn.addEventListener('click', () => {
                instructionsOverlay.style.display = 'none';
                clock.start(); 
                animate(); 
            });

            // Initial setup: call render once to show the initial scene
            renderer.render(scene, camera);
        }

        function createWorld() {
            // Lunar Ground Plane
            const groundGeometry = new THREE.PlaneGeometry(80, 80, 64, 64);
            // Add some height variation for a rugged look
            const positionAttribute = groundGeometry.attributes.position;
            for (let i = 0; i < positionAttribute.count; i++) {
                const z = positionAttribute.getZ(i);
                positionAttribute.setZ(i, z + Math.random() * 0.5 - 0.25); 
            }
            groundGeometry.computeVertexNormals(); 

            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = groundCollisionY; 
            ground.receiveShadow = true;
            scene.add(ground);

            // Create Project Structures (Adjusted Y positions for new ground Y=0)
            const projectData = [
                { name: "Server Array", description: "Full Stack API & Backend", type: "monolith", position: { x: 10, z: 8 }, link: "https://github.com/repo1" },
                { name: "AI Core", description: "Machine Learning & Data Pipelines", type: "dome", position: { x: -12, z: 0 }, link: "https://github.com/repo2" },
                { name: "Game Engine Hub", description: "WebGL & Interactive Experiences", type: "comm", position: { x: 0, z: -15 }, link: "https://github.com/repo3" },
                { name: "Data Repository", description: "Database Management & ETL", type: "monolith", position: { x: 5, z: -5 }, link: "https://github.com/repo4" },
                { name: "Simulation Chamber", description: "Physics & AI Agent Testing", type: "dome", position: { x: -8, z: 10 }, link: "https://github.com/repo5" },
            ];

            projectData.forEach(data => {
                let mesh;
                if (data.type === "monolith") {
                    const geo = new THREE.BoxGeometry(2, 4, 2);
                    mesh = new THREE.Mesh(geo, projectMaterial.clone());
                    mesh.position.y = 2.0; 
                } else if (data.type === "dome") {
                    const geo = new THREE.SphereGeometry(2, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2); 
                    mesh = new THREE.Mesh(geo, projectMaterial.clone());
                    mesh.rotation.x = -Math.PI / 2;
                    mesh.position.y = 2.0; 
                } else if (data.type === "comm") {
                    // Communication dish
                    const dishGeo = new THREE.CylinderGeometry(0.2, 0.2, 3, 8);
                    const dishMesh = new THREE.Mesh(dishGeo, projectMaterial.clone());
                    dishMesh.position.y = 1.5;

                    const antennaGeo = new THREE.CylinderGeometry(2, 2, 0.5, 32);
                    const antennaMesh = new THREE.Mesh(antennaGeo, projectMaterial.clone());
                    antennaMesh.rotation.x = Math.PI / 2;
                    antennaMesh.position.set(0, 1.5 + 1.5, 0);

                    mesh = new THREE.Group();
                    mesh.add(dishMesh);
                    mesh.add(antennaMesh);
                    mesh.position.y = 1.0; 
                }

                if (mesh) {
                    mesh.position.x = data.position.x;
                    mesh.position.z = data.position.z;
                    mesh.userData = data; 
                    mesh.castShadow = true;
                    scene.add(mesh);
                    projects.push(mesh);
                }
            });

            // Create Data Rover
            const bodyGeo = new THREE.BoxGeometry(1, 0.5, 1.5);
            const bodyMesh = new THREE.Mesh(bodyGeo, roverMaterial);
            bodyMesh.position.y = 0.25; 

            const antennaGeo = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
            const antennaMesh = new THREE.Mesh(antennaGeo, roverMaterial);
            antennaMesh.position.set(0, 0.75, -0.5); 
            antennaMesh.castShadow = true;

            rover = new THREE.Group();
            rover.add(bodyMesh);
            rover.add(antennaMesh);
            rover.position.set(0, 0.5, 0); 
            scene.add(rover);
        }

        function createLights() {
            // Ambient Light (Overall dim illumination for space)
            const ambientLight = new THREE.AmbientLight(0x404040, 3);
            scene.add(ambientLight);

            // Directional Light (Simulating a distant star/sun)
            const sunLight = new THREE.DirectionalLight(0xffffff, 5);
            sunLight.position.set(20, 30, 20);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 100;
            sunLight.shadow.camera.left = -50;
            sunLight.shadow.camera.right = 50;
            sunLight.shadow.camera.top = 50;
            sunLight.shadow.camera.bottom = -50;
            scene.add(sunLight);

            // A subtle fill light from another direction
            const fillLight = new THREE.DirectionalLight(0x87CEEB, 1);
            fillLight.position.set(-15, 10, -15);
            scene.add(fillLight);
        }

        // --- Keyboard Input Handlers ---
        function onKeyDown(event) {
            keyStates[event.key.toLowerCase()] = true;
        }

        function onKeyUp(event) {
            keyStates[event.key.toLowerCase()] = false;
            
            // When key is released, reset the accumulated force for that axis (this is physics 
            // from the old version, kept for compatibility, but the integration step below is primary)
            if (roverForce && (event.key.toLowerCase() === 'w' || event.key.toLowerCase() === 's')) {
                roverForce.z = 0;
            }
            if (roverForce && (event.key.toLowerCase() === 'q' || event.key.toLowerCase() === 'e')) {
                roverForce.y = 0;
            }
        }

        // --- Event Handlers (Resize and Pointer Move) ---
        function onWindowResize() {
            // Check if camera and renderer are initialized
            if (!camera || !renderer) return;
            
            const width = container.clientWidth;
            const height = container.clientHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            renderer.setSize(width, height);
        }

        function onPointerMove(event) {
            // FIX: Check if pointer is initialized before using it
            if (!pointer || !raycaster || !camera || !projects) return; 

            // Calculate mouse position in normalized device coordinates (-1 to +1)
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Check for project object intersection (raycasting for hover)
            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(projects, true);

            if (intersects.length > 0) {
                let currentIntersected = intersects[0].object;
                // Find the top-level project object
                while (currentIntersected && !currentIntersected.userData.name) {
                    currentIntersected = currentIntersected.parent;
                }

                if (currentIntersected && intersectedObject !== currentIntersected) {
                    // Reset previous intersected object's material
                    if (intersectedObject) {
                        intersectedObject.traverse(child => {
                            if (child.isMesh) child.material = projectMaterial.clone();
                        });
                    }

                    // Set new intersected object's material and update UI
                    intersectedObject = currentIntersected;
                    intersectedObject.traverse(child => {
                        if (child.isMesh) {
                            const highlightMaterial = projectMaterial.clone();
                            highlightMaterial.emissiveIntensity = 0.5;
                            highlightMaterial.color.setHex(0x38BFF8);
                            child.material = highlightMaterial;
                        }
                    });

                    // Update UI Info Box
                    if(infoTitle) infoTitle.textContent = intersectedObject.userData.name;
                    if(infoDescription) infoDescription.textContent = intersectedObject.userData.description;
                    if(infoLink) {
                        infoLink.href = intersectedObject.userData.link;
                        infoLink.classList.remove('invisible');
                    }
                    if(infoBox) {
                        infoBox.style.opacity = '1';
                        infoBox.style.pointerEvents = 'auto';
                    }
                }
            } else {
                // No intersection
                if (intersectedObject) {
                    intersectedObject.traverse(child => {
                        if (child.isMesh) child.material = projectMaterial.clone();
                    });
                    intersectedObject = null;
                    if(infoBox) infoBox.style.opacity = '0';
                    if(infoLink) infoLink.classList.add('invisible');
                    if(infoBox) infoBox.style.pointerEvents = 'none';
                }
            }
        }

        // --- Animation Loop (Physics Core) ---
        function animate() {
            requestAnimationFrame(animate);
            
            // FIX: Check if all physics objects are initialized before using them
            if (!clock || !controls || !roverForce || !roverVelocity || !rover) return; 

            const dt = clock.getDelta(); // Get time elapsed since last frame
            controls.update();

            // Damping factor for linear braking while turning (0.6 retained speed)
            const turnDamping = Math.pow(turnLinearBrakingFactor, dt);
            // Damping factor for full stop on key release (0.1 retained speed)
            const generalBrakingDamping = Math.pow(generalLinearBrakingFactor, dt);

            // 1. Reset Force Vector for this frame
            roverForce.set(0, 0, 0);
            roverForce.y -= roverMass * lunarGravity; // Apply constant Lunar Gravity

            // --- 2. Handle Rotation (A/D) with Acceleration/Damping ---
            let angularAcceleration = 0;
            const isTranslating = keyStates['w'] || keyStates['s']; // Check for forward/backward movement
            const isRotating = keyStates['a'] || keyStates['d'];

            if (keyStates['a']) {
                angularAcceleration += roverAngularAcceleration;
                
                // APPLY LINEAR BRAKING WHILE TURNING LEFT (Reduces drift)
                if (isTranslating) {
                    roverVelocity.x *= turnDamping;
                    roverVelocity.z *= turnDamping;
                }
            }
            if (keyStates['d']) {
                angularAcceleration -= roverAngularAcceleration;
                
                // APPLY LINEAR BRAKING WHILE TURNING RIGHT (Reduces drift)
                if (isTranslating) {
                    roverVelocity.x *= turnDamping;
                    roverVelocity.z *= turnDamping;
                }
            }
            
            // 3. Update Angular Velocity
            roverAngularVelocity += angularAcceleration * dt;

            // Apply Angular Damping (always applied)
            const angularDampingFactor = Math.pow(roverAngularDamping, dt);
            roverAngularVelocity *= angularDampingFactor;

            // Apply STRONG Angular Braking if keys are released
            if (!keyStates['a'] && !keyStates['d']) {
                const rotationBrakingFactor = Math.pow(0.3, dt); // Fast rotational stop
                roverAngularVelocity *= rotationBrakingFactor;
                
                // Also apply strong linear braking on rotation release
                roverVelocity.x *= generalBrakingDamping;
                roverVelocity.z *= generalBrakingDamping;
            }

            // Apply Rotation to Rover
            rover.rotation.y += roverAngularVelocity * dt;

            // --- 4. Apply Linear Thrust Forces (W/S & Q/E) ---
            const localThrust = new THREE.Vector3(0, 0, 0);

            // Forward/Backward (W/S)
            if (keyStates['w']) {
                localThrust.z -= thrustMagnitude; 
            }
            if (keyStates['s']) {
                localThrust.z += thrustMagnitude * 0.5; 
            }

            // Vertical Movement (Q/E)
            if (keyStates['q']) {
                localThrust.y += thrustMagnitude * 0.3; // Milder thrust
            }
            if (keyStates['e']) {
                localThrust.y -= thrustMagnitude * 0.3; // Milder thrust
            }

            // Convert local Z thrust to World coordinates and add to global force
            localThrust.applyQuaternion(rover.quaternion);
            roverForce.add(localThrust);

            // 5. Integration: Update Velocity using (F/m * dt)
            roverVelocity.x += roverForce.x / roverMass * dt;
            roverVelocity.y += roverForce.y / roverMass * dt;
            roverVelocity.z += roverForce.z / roverMass * dt;


            // --- 6. Apply Linear Damping (Friction and Braking) ---
            const horizontalDampingFactor = Math.pow(roverFriction, dt);
            const verticalDampingFactor = Math.pow(airFriction, dt);
            
            // Standard damping when actively translating (W/S)
            if (isTranslating && !isRotating) { 
                roverVelocity.x *= horizontalDampingFactor;
                roverVelocity.z *= horizontalDampingFactor;
            } else if (!isTranslating && !isRotating) {
                // If all keys are released (redundancy: ensures stop even if rotation keys weren't used)
                roverVelocity.x *= generalBrakingDamping;
                roverVelocity.z *= generalBrakingDamping;
            }

            roverVelocity.y *= verticalDampingFactor; // Vertical damping always applies

            // Hard stop residual linear velocity
            if (roverVelocity.lengthSq() < 0.001 && !isTranslating) {
                roverVelocity.x = 0;
                roverVelocity.z = 0;
            }
            // Hard stop residual angular velocity
            if (!isRotating && Math.abs(roverAngularVelocity) < 0.001) {
                 roverAngularVelocity = 0;
            }


            // 7. Apply Movement to Position
            rover.position.addScaledVector(roverVelocity, dt);

            // 8. Altitude Control and Ground Constraint
            const hoverAltitude = groundCollisionY + 0.5 + Math.sin(clock.getElapsedTime() * 2) * 0.05;

            // Ground Limit (Hard Floor)
            if (rover.position.y <= groundCollisionY + 0.1) {
                rover.position.y = groundCollisionY + 0.1;
                
                // Only allow upward velocity when on the ground
                if (roverVelocity.y < 0) {
                    roverVelocity.y = 0; 
                }
            } 
            
            // Soft spring back to hover altitude (only applies when not actively Q/E thrusting)
            if (!keyStates['q'] && !keyStates['e']) {
                const targetY = hoverAltitude;
                const restoreForce = (targetY - rover.position.y) * roverMass * 0.4;
                roverVelocity.y += restoreForce / roverMass * dt;
            }


            // 9. Update Camera Target (to follow the Rover)
            controls.target.lerp(rover.position, 0.1);

            renderer.render(scene, camera);
        }

        // --- Start Application ---
        document.addEventListener('DOMContentLoaded', () => {
            init();
        });

    </script>
</body>
</html>

